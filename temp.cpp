struct bignum\n{\n    vector<short> digit; bool negative = false;\n    bignum() {\n        digit = vector<short>();\n        negative = false;\n    };\n    bignum(int in) {\n        if (in < 0) {\n            negative = true;\n            in *= -1;\n        }\n        else \n        if (in == 0) {\n            digit = vector<short>({0});\n            negative = false;\n            return;\n        }\n        while (in) {\n            digit.push_back(in % 10);\n            in /= 10;\n        }\n    }\n    bignum(vector<short> inp1, bool inp2) {\n        digit = inp1;\n        negative = inp2;\n    }\n    void check(bignum& a, bignum& b) {\n        while (a.digit.size() < b.digit.size())\n            a.digit.push_back(0);\n        while (a.digit.size() > b.digit.size())\n            b.digit.push_back(0);\n    }\n    bignum check(bignum in) {\n        if (in.digit.size() == 0)\n            return tobignum(0, false);\n        while(*(in.digit.end() - 1) == 0 && in.digit.size() > 1)\n            in.digit.pop_back();\n        return in;\n    }\n    long long toll(bignum in) {\n        long long ou = 0;\n        for (unsigned i = 0; i < in.digit.size(); i++)\n            ou += in.digit[i] * (pow(10, i));\n        if (in.negative)\n            ou = 0 - ou;\n        return ou;\n    }\n    bignum tobignum(long long in, bool negative) {\n        bignum ou;\n        ou.negative = negative;\n        in = abs(in);\n        if (!in)\n            ou.digit = {0};\n        else \n            while (in) {\n                ou.digit.push_back(in % 10);\n                in /= 10;\n            }\n        return ou;\n    }\n    friend istream& operator>>(istream& iostr, bignum& in) {\n        string input; iostr >> input;\n        in.digit.clear();\n        while (input.size()) {\n            if (isdigit(*(input.end()-1)))\n                in.digit.push_back(*(input.end()-1) - '0');\n            else \n            if (*(input.end()-1) == '-')\n                in.negative = true;\n            input.pop_back();\n        }\n        while (*(in.digit.end()-1) == 0)\n            in.digit.pop_back();\n        return iostr;\n    }\n    friend ostream& operator<<(ostream& iostr, bignum in) {\n        if (in.negative) iostr << "-";\n        while (in.digit.size()) {\n            iostr << (*(in.digit.end()-1));\n            in.digit.pop_back();\n        }\n        return iostr;\n    }\n    bignum operator+(bignum in) {\n        auto a = check(*this); auto b = check(in); check(a, b);\n        if (a.negative != b.negative) {\n            if (a.negative) return check(tru(b, a));\n            else            return check(tru(a, b));\n        }\n        return check(cong(a, b));\n    }\n    bignum operator-(bignum in) {\n        auto a = check(*this); auto b = check(in); check(a, b);\n        if (b.negative)\n            return check(bignum{b.digit, false} + a);\n        return check(tru(a, b));\n    }\n    bignum operator-=(bignum in){\n        *this = *this - in;\n        return *this;\n    }\n    bignum operator*(bignum in) {\n        auto a = check(*this); auto b = check(in);\n        if (a > b)\n            swap(a, b);\n        if (a.digit.size() == 1)\n            return nhan1(a, b);\n        auto length = a.digit.size()/2;\n        bignum  righA = {vector<short> (a.digit.begin(), a.digit.begin() + length), false},\n                leftA = {vector<short> (a.digit.begin() + length, a.digit.end()), false},\n                righB = {vector<short> (b.digit.begin(), b.digit.begin() + length), false},\n                leftB = {vector<short> (b.digit.begin() + length, b.digit.end()), false},                \n        t0 = righA * righB,\n        t1 = (leftA * righB) + (leftB * righA),\n        t2 = leftA * leftB, \n        ou = nhan10(t2,(length) * 2) + nhan10(t1, length) + t0;\n        ou.negative = (a.negative ^ b.negative);\n        return ou;\n    }\n    bignum operator/(bignum in) {\n        bignum a = check(*this), b = check(in), ou, temp(0);\n        if (a.digit.size() < b.digit.size())\n            return tobignum(0, false);\n        ou.digit.clear(); b.negative = a.negative = false;\n        auto iter = a.digit.rbegin();\n        while (iter != a.digit.rend()) {\n            temp = temp * 10 + bignum(*iter);\n            unsigned count = 0;\n            while (temp >= b) \n                temp -= b, count++;\n            ou = ou * 10 + count;\n            iter++;\n        }\n        ou.negative = ((*this).negative ^ in.negative);\n        return ou;\n    }\n    short tru(short a, short b, unsigned* du) {\n        *du = 0; short ou = a - b;\n        if (ou < 0) {\n            *du = 1;\n            return 10 + ou;\n        }\n        return ou;\n    }\n    bignum tru(bignum a, bignum b) {\n        bignum ou;\n        if (less(a, b)) {\n            ou = bignum{b.digit, false} - a;\n            ou.negative = true;\n            return ou;\n        }\n        unsigned du = 0; ou.negative = a.negative;\n        ou.digit.push_back(tru(a.digit[0], b.digit[0], &du));\n        for (unsigned i = 1; i < a.digit.size(); i++) {\n            unsigned Du1 = 0, Du2 = 0;\n            ou.digit.push_back(tru(tru(a.digit[i], b.digit[i], &Du1), du, &Du2) % 10);\n            du = Du1 || Du2;\n        }\n        if (!toll(ou))\n            ou.negative = false;\n        return ou;\n    }\n    bignum cong(bignum a, bignum b) {\n        unsigned du = 0; vector<short> ou; ou.clear();\n        ou.push_back((a.digit[0] + b.digit[0]) % 10);\n        du = bool(a.digit[0] + b.digit[0] > 9);\n        for (unsigned i = 1; i < a.digit.size(); i++) {\n            ou.push_back((a.digit[i] + b.digit[i] + du) % 10);\n            du = bool(a.digit[i] + b.digit[i] + du > 9);\n        }\n        ou.push_back(du);\n        while (*ou.begin() == '0')\n            ou.erase(ou.begin());\n        return {ou, a.negative};\n    }\n    bignum nhan1(bignum a, bignum b) {\n        int gun = toll(a), du = 0;\n        for (auto& digit : b.digit) \n            digit *= gun, digit += du, du = digit / 10, digit %= 10;\n        b.digit.push_back(du);\n        return b;\n    }\n    bignum nhan10(bignum in, long long length) {\n        while (length--)\n            in.digit.insert(in.digit.begin(), 0);\n        return in;\n    }\n    bool operator<(bignum in) {\n        auto a = *this; auto b = in;\n        if (a.negative != b.negative)\n            return a.negative;\n        bool equal, ou = less(a, b, &equal);\n        return ou ^ a.negative && !equal;\n    }\n    bool operator>(bignum in) {\n        auto a = *this; auto b = in;\n        if (a.negative != b.negative)\n            return !a.negative;\n        bool equal, ou = !less(a, b, &equal);\n        return ou ^ a.negative && !equal;\n    }\n    bool operator==(bignum in) {\n        bool ou = false;\n        less(*this, in, &ou);\n        return ou && ((*this).negative == in.negative);\n    }\n    bool operator>=(bignum in) {\n        return !(*this < in) || *this == in;\n    }\n    bool operator<=(bignum in) {\n        return *this < in || *this == in;\n    }\n    bool less(bignum left, bignum righ, bool* equal = nullptr) {\n        if (equal   != nullptr) *equal = false; check(left, righ);\n        while (*(left.digit.end()-1) == *(righ.digit.end()-1) && left.digit.size() > 0) {\n            left.digit.pop_back();\n            righ.digit.pop_back();\n        }\n        if (left.digit.size()) {\n            bool ou = (*(left.digit.end()-1) < *(righ.digit.end()-1));\n            return ou;\n        }\n        if (equal != nullptr) *equal = true;\n        return false;\n    }\n};